<?php
// $Id$

/**
 * @file
 * Enables communication between Drupal and VoIP servers.
 */


/**
 * Sends a request to the active voip server
 *
 * @param $request
 *   The request to be executed
 *
 * @param $options
 *   An array of additional options as defined by each request
 */
function voip_send_request($request, $options = array()) {
  $response[status] = TRUE;
  $voip_server = voip_default_server();

  if (function_exists($voip_server['send'])) {
    $response = $voip_server['send']($request, $options);
  }

  if (!$response['status']) {
    $error_message = 'Failure executing request %request.';
    $variables['%request'] = $request;
    if ($response['error_msg']) {
      $error_message .= ' The server said '. $response['error_msg'];
      if (!empty($response['options'])) {
        $options = array_merge($options, $response['options']);
      }
    }
    // TODO: shall we implement a mechanism similar to xmlrpc_error() to distinguish between processing errors and communication errors with the server? This way, we wouldn't need to report WATCHDOG_ERROR for non-system errors...
    watchdog('voip', $error_message, $options, WATCHDOG_ERROR);
  }
  return $response;
}


/**
 * Implementation of hook_xmlrpc().
 * Map external names of XML-RPC methods to PHP callback functions.
 */
function voip_xmlrpc() {
  $methods = array();

  $methods[] = array(
    'voip.hello',      // External method name.
    'xmls_voip_hello', // PHP function to run.
    array('string', 'string'),// The return value's type, then any parameter types.
    t('Greets XML-RPC clients by name.')  // Description.
  );

  $methods[] = array(
    'voip.processRequest',      // External method name.
    'xmls_voip_process_request', // PHP function to run.
    array('array', 'string', 'array'),// The return value's type, then any parameter types.
    t('Processes incoming requests from VoIP servers.')  // Description.
  );

  // NOTE: the following method is only here for test purposes. In the real system it should never be called via xmlrpc.
  $methods[] = array(
    'voip.sendRequest',
    'voip_send_request', 
    array('array', 'string', 'array'),
    t('Send request to default VoIP server.')
  );

  return $methods;
}


/**
 * Implementation of hook_menu().
 */
function voip_menu() {
  $items = array();

  $items['admin/voip'] = array(
    'title' => 'Voip Drupal',
    'description' => 'Control how your site interacts with VoIP servers.',
    'position' => 'right',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer voip drupal framework'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system')
  );

  $items['admin/voip/servers'] = array(
    'title' => 'Voip server configuration',
    'description' => 'Configure voip servers and choose the default server.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('voip_admin_default_form', NULL),
    'access arguments' => array('administer voip drupal framework'),
    'file' => 'voip.admin.inc',
  );

  $items['admin/voip/servers/%'] = array(
    'title callback' => 'voip_admin_server_title',
    'title arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('voip_admin_server_form', 3),
    'access arguments' => array('administer voip drupal framework'),
    'type' => MENU_CALLBACK,
    'file' => 'voip.admin.inc',
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function voip_perm() {
  return array('administer voip drupal framework');
}


/**
 * Implementation of hook_theme().
 */
function voip_theme() {
  $items['voip_admin_default_form'] = 
       array('arguments' => array('form' => NULL));

  return $items;
}


/**
 * Internal functions
 */

/**
 * Voip server menu title callback.
 */
function voip_admin_server_title($server_id) {
  $server = voip_servers('server', $server_id);
  return sprintf('%s server', $server['name']);
}

/**
 * Returns the current default voip server.
 */
function voip_default_server() {
  return voip_servers('server', variable_get('voip_default_server', 'log'));
}

/**
 * Calls hook_voip_server_info to retrieve a list of all voip servers
 * defined in the system.
 *
 * Similar to the SMS framework (http://drupal.org/node/362261),
 * hook_voip_server_info() might be defined as follows:
 *
 * function mymodule_voip_server_info() {
 *   return array(
 *     'my_voip_server_id' => array(
 *       'name' => 'My Voip Server',
 *       'send' => 'mymodule_send',
 *       'receive' => TRUE,
 *       'configure form' => 'mymodule_admin_form',
 *       'send form' => 'mymodule_send_form',
 *     );
 *   );
 * }
 * 
 * Where
 *    * name - Human readable name for the voip server.
 *    * send - Callback function that the Voip Framework will call to send a comand to the server
 *    * receive (optional) - Set to true if the server has support for handling incoming requests
 *    * configure form (optional) - Form function for server configuration options
 *    * send form (optional) - Form function for adding server-specific fields to the sending form
 *
 *
 *
 * @param $op
 *   The format in which to return the list. When set to 'server' or 'name',
 *   only the specified server is returned. When set to 'servers' or 'names',
 *   all servers are returned.
 *
 * @param $server
 *   A server identifier string that indicates the server to return. Leave
 *   at the default value (NULL) to return all servers.
 *
 * @return
 *   Either an array of all servers or a single server, in a variable format.
 */
function voip_servers($op = 'servers', $server = NULL) {
  $_servers = array();
  $_names = array();

  $server_array = module_invoke_all('voip_server_info');
  foreach ($server_array as $identifier => $info) {
    // retrieve server-specific configuration
    $info['configuration'] = variable_get('voip_'. $identifier .'_settings', '');
    $_servers[$identifier] = $info;
    $_names[$identifier] = $info['name'];
  }
  asort($_names);

  switch ($op) {
    case 'servers':
      return $_servers;
    case 'server':
      $rc = $_servers[$server];
      $rc['identifier'] = $server;
      return $rc;
    case 'names':
      return $_names;
    case 'name':
      return $_names[$server];
  }
}


/**
 * Implementation of hook_voip_server_info().
 */
function voip_voip_server_info() {
  return array(
    'log' => array(
      'name' => t('Log only'),
      'send' => 'voip_send_log',
    ),
  );
}

function voip_send_log($request, $options) {
  watchdog('voip', 'Voip request %request sent with the following options: @options', array('%request' => $request, '@options' => print_r($options, TRUE)), WATCHDOG_INFO);
  return array('status' => TRUE);
}






/**
 * Greet a user.
 */
function xmls_voip_hello($name) {
  if (!$name) {
    return xmlrpc_error(1, t('I cannot greet you by name if you do not provide one.'));
  }
  return t('Hello, @name!', array('@name' => $name));
}


/**
 * Process requests received from VoIP servers.
 */
function xmls_voip_process_request($request_id, $options=array())
{
  $response['status'] = TRUE;

  // give modules an opportunity to validate request
  foreach (module_implements('voip_inbound_validate') as $module) {
    $function = $module .'_'. 'voip_inbound_validate';
    $result = call_user_func($function, $request_id, $options);
    // stop at the first validation error
    if (isset($result['status']) && ($result['status'] == FALSE)) {
      $response = array('status' => FALSE,
                        'error_msg' => $result['error_msg']);
      break;
    }
  }
    
  // process request
  if ($response['status']) {
    $response = NULL;
    foreach (module_implements('voip_inbound') as $module) {
      $function = $module .'_'. 'voip_inbound';
      // NOTE: in case of success, modules are not supposed to return 'status' set to TRUE. That would mess $response after the array_merge_recursive() below. In case of failure, modules should return 'status' set to FALSE and an appropriate 'error_msg'
      $result = call_user_func($function, $request_id, $options);
      // stop at the first execution error
      if (isset($result)) {
        if ($result['status'] == FALSE) {
          $response = array('status' => FALSE,
                            'error_msg' => $result['error_msg']);
          break;
        }
        else {
          $response['status'] = TRUE;
          $response = array_merge_recursive($response, $result);
        }
      }
    }
    if (!$response) {
      $response['status'] = FALSE;
      $response['error_msg'] = 'Request not processed by any module.';
    }
  }   
  return $response;
}

