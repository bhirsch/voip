<?php
// Automatically generated by features module.
include_once('callblast.features.inc');

// Custom code and logic.
include_once('callblast.inc');

/**
 * @file callblast.module
 *   Drupal hooks implemented for VOIP call blasts.
 */ 
/**
 * Implementation of hook_help(). 
 */
function callblast_help($path, $arg) {
  if ($path == 'admin/help#callblast') {
    $txt = t('This module creates provides voip '
            .'call blast functionality. ');
    return $txt;
  }
}

/**
 * Implementation of hook_menu().
 */
function callblast_menu() {
  $items = array();

 // Call back for auto-complete on node/add and node/edit form
  $items['callblast/list/autocomplete'] = array(
    'title' => 'Call Blast Autocomplete List',
    'page callback' => 'callblast_list_autocomplete',
    'access arguments' => array('edit extension'),
    'type' => MENU_CALLBACK,
    'file' => 'callblast.inc',
  );
  
  return $items;
}

/**
 * Implementation of hook_nodeapi().
 */
function callblast_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  // create call nodes from call blast's call list
  if ($node->type == 'callblast') { 
    switch($op) {
      case 'insert': 
      // Get selected call list
      $list_name = check_plain($node->field_callblast_calllist[0]['value']);
      $list = module_invoke_all('callblast_get_list', $list_name);

      // Set up batch 
      $size = 5; // save up 5 nodes at a time
      // generic call details from callblast node
      $details['script'] = $node->field_callblast_script[0]['nid'];
      $details['caller number'] = $node->field_callblast_caller_number[0]['value'];
      $details['caller name'] = $node->field_callblast_caller_name[0]['value'];
      $details['parent node'] = $node->nid;
      $details['scheduled start'] = $node->field_callblast_scheduled_start[0]['value'];
      // batch
      $batch = array(
         'operations' => array(
           array('callblast_save_voipcall_nodes', array($size, $list, $details, $node),),
           ),
         'finished' => 'callblast_save_voipcall_nodes_finished',
         'title' => t('Scheduling calls'),
         'init_message' => t('Creating records for each phone number on call list'),
         'progress_message' => t('Scheduled @current of @total calls.'),
         'error_message' => t('Processing error'),
      );
      $url = "node/$node->nid";
      // Save voipcall nodes
      batch_set($batch);
      batch_process($url);
    break;
    
    case 'update': 
      /**
       * Check for changes to the call list by 
       * comparing $list and $callblast_call_list.
       *
       *  $list will have the most up-to-date version of 
       * the users call list. 
       *
       * $callblast_call_list will have the saved call list
       * as of the last update/save. $list should override $callblast_list.
       */
      // get $list       
      $list_name = check_plain($node->field_callblast_calllist[0]['value']);
      $list = module_invoke_all('callblast_get_list', $list_name);
dsm($list);      
      // get $callblast_list
      // then compare lists and update callblast_call table where appropriate            
// TODO 
// CONTINUE HERE
// This might require batch processing. Need to do node loads to get phone numbers.
// Maybe use litenode here?  

 
    break;
    }
  }
}

// HOOK_NODEAPI -> CREATE CALL NODES ON SAVE
// CALL RELATED CALL NODES ON CRON
// USE CALL BLAST'S MESSAGE
// README.txt, explain hooks implemented in calllist module
// FORM ALTER TO PREVENT MANUAL CREATION OF CALLS (LIKE EXTENSIONS)?
// PROVIDE ADMIN SETTINGS FORM TOE ENABLE MANUAL CREATION OF CALLS? 
// BUILD CIVICRM MODULE


/**
 * On cron, run call blasts.
 * 
 * TODO This is untested. TEST!
 * 
 * TODO Add test call before running call blast.
 * TODO Enable user to schedule date/time for test call and blast.
 * TODO Call node_save to update list before running blast. If people have been deleted from a dynamic list, don't call them.
 * 
 * Implementation of hook_cron().
 */
function callblast_cron() {
  // check for call blasts that have been scheduled but not sent
  $sql = "SELECT n.nid, n.vid " 
        ."FROM {node} n " 
        ."JOIN {content_type_callblast} cb ON n.nid = cb.nid "
        ."WHERE field_blast_sent_value = 0";
        // TODO add AND where TIME_SCHEDULED < CURRENT_TIME
  $result = db_query($sql);

  // @todo these should be added to a queue. Lots of big lists could get messy.
  // loop through unblasted blast lists and blast them
  while ($row = db_fetch_object($result)) {
    $callblast_nid = $row->nid;
    $callblast_vid = $row->vid;

    // get list of phone numbers for the current call blast list
    $sql = 'SELECT voipcall_nid FROM {callblast_call} WHERE callblast_nid = %d'; 
    $result2 = db_query($sql, $callblast_nid);

    // place phone calls to each number on the list, one-by-one
    while ($voipcall_nid = db_result($result2)) { 
      $voipcall_node = node_load($voipcall_nid);    

      // $request_id, Type of call being requested.
      $request_id = 'voip_dial_out';

      // place outgoing call
      voip_send_request($request_id, $voipcall_node);
    }
    // Update node to indicate that blast has been sent.
    db_query("UPDATE {content_type_callblast} "
            ."SET field_blast_sent_value = 1 " 
            ."WHERE nid = %d " 
            ."AND vid = %d ",
             $nid, $vid);
    // Clear cache to reflect update.
    cache_clear_all('content:'. $nid .':'. $vid, content_cache_tablename()); 
 
    // Log call blast with watchdog
    $type = 'call blast';
    $message = t("Call blast nid-$nid sent.");
    $severity = WATCHDOG_NOTICE;
    watchdog($type, $message);
  }
}

/**
 * Batch call back operation: Save voipcall nodes.
 * 
 * @param
 *  $size, number of phone numbers to save per pass 
 * 
 * @param
 *  $list, full call list with phone numbers and any other 
 *  details supplied by the module that created it.
 * 
 *  $node, callblast node, including default values to send to voipcall_save().
 */
function callblast_save_voipcall_nodes($size, $list, $details, $node) {
  // Initialize sandbox the first time through.
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 1;
    $context['sandbox']['i'] = 0;
    $context['sandbox']['max'] = count($list);
  }
  
  // set range of numbers to be processed
  $i = $context['sandbox']['i'];
  $j = 0;
  $max = $context['sandbox']['max']; 

  // save up voipcall nodes from $list
  while ($i < $max && $j < $size) {
    if ($list[$i]['destination']) {
      $details['destination'] = $list[$i]['destination'];
      // save voipcall node
      voipcall_save($details);
      // store callblast_nid / voipcall_nid pairs in  callblast_call table
      $callblast_call->voipcall_nid = db_last_insert_id('node', 'nid');
      $callblast_call->callblast_nid = $node->nid;
      drupal_write_record('callblast_call', $callblast_call);
    } else {
      // no destination number
      // TODO Add validation/error handling here. 
      //   Right now we're just checking for something or nothing. 
      //   But, for example, a 6 digit phone number should trigger an error too.
      drupal_set_message(t('Invalid destination number on call list.'), 'warning');
    }
    $i++;
  }

  // update progress information
  $context['sandbox']['progress']++;
  $context['sandbox']['i'] = $i;
  $context['message'] = t('Scheduling %callnum', array('%callnum' => $list[$i]['destination']));

  // Let the batch engine know how close we are to completion.
  if ($context['sandbox']['progress'] == $context['sandbox']['max']) {
    // Done!
    $context['finished'] = 1;
    $context['results'] = $context['sandbox']['max'];
    // incase 'finished' function wants to use these
  } else {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }  
}

/**
 * Batch finished. Called when batch operations are complete.
 */
function callblast_save_voipcall_nodes_finished($success, $results, $operations) {
  if ($success) {
    $txt = t('Call blast set up complete.');
    drupal_set_message($txt);
  } else {
    // a fatal error occurred during batch processing
    $error_operation = reset($operations);
    $operation = array_shift($error_operation);
    $arguments = array_shift($error_operation);
    $arguments_as_string = implode(', ', $arguments);
    watchdog('callblast', "Error when calling operation '%s'('%s')", array($operation, $arguments_as_string));
    drupal_set_message(t('An error occurred and has been recorded in the system log.'), 'error');
  }
}
//==========================================//
// DEFINING THE CALLIST WIDGET
// see example:  http://www.lullabot.com/articles/creating-custom-cck-fields
//==========================================//

/**
* Implementation of hook_widget_info().
*
* Here we indicate that the content module will handle
* the default value and multiple values for these widgets.
*
* Callbacks are omitted because default handing is used.
*/
function callblast_widget_info() {
  return array(
    // The machine name of the widget, no more than 32 
    // characters.
    'callblast_calllist' => array(
      // The human-readable label of the field that will be 
      // seen in the Manage fields screen.
      'label' => t('Call List'),
      // An array of the field types this widget can be 
      // used with.
      'field types' => array('text'),
      // Who will handle multiple values, default is core.
      // 'CONTENT_HANDLE_MODULE' means the module does it.
      // See optionwidgets for an example of a module that 
      // handles its own multiple values.
//      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        // Who will create the default value, default is core.
        // 'CONTENT_CALLBACK_CUSTOM' means the module does it.
        // 'CONTENT_CALLBACK_NONE' means this widget has 
        // no default value.
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
* Implementation of hook_widget_settings().
* 
* TODO Add hok_widget_settings(). 
* Allow multiple values? (e.g. combine call lists 
* like "summer volunteers" + "interns" CiviCRM groups?)
*/

/**
* Implementation of hook_widget().
*
* @param $form
*   the entire form array, 
*   $form['#node'] holds node information
* @param $form_state
*   the form_state, 
*   $form_state['values'][$field['field_name']]
*   holds the field's form values.
* @param $field
*   the field array
* @param $items
*   array of default values for this field
* @param $delta
*   the order of this item in the array of 
*   subelements (0, 1, 2, etc)
*
* @return
*   the form item for a single element for this field
*/
function callblast_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  $element['value'] = array(
    '#title' => t('Call List'), 
    '#type' => 'textfield',
    '#default_value' => isset($items[$delta]['value']) ? $items[$delta]['value'] : NULL,
    '#autocomplete_path' => 'callblast/list/autocomplete',
    '#size' =>  60,
    '#attributes' => array('class' => 'callblast_calllist'),
    '#maxlength' => !empty($field['max_length']) ? $field['max_length'] : NULL,
  );
  
  // Used so that hook_field('validate') knows where to 
  // flag an error in deeply nested forms.
  if (empty($form['#parents'])) {
    $form['#parents'] = array();
  }
  $element['_error_element'] = array(
    '#type' => 'value',
    '#value' => implode('][', array_merge($form['#parents'], array('value'))),
  );
  return $element;
}


