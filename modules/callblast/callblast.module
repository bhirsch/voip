<?php
// Automatically generated by features module.
include_once('callblast.features.inc');

// Custom code and logic.
include_once('includes/callblast.inc');
include_once('includes/callblast.script.inc');

/**
 * @file callblast.module
 *   Drupal hooks implemented for VOIP call blasts.
 */ 
/**
 * Implementation of hook_help(). 
 */
function callblast_help($path, $arg) {
  if ($path == 'admin/help#callblast') {
    $txt = t('This module creates provides voip '
            .'call blast functionality. ');
    return $txt;
  }
}

/**
 * Implementation of hook_menu().
 */
function callblast_menu() {
  $items = array();

 // Call back for auto-complete on node/add and node/edit form
  $items['callblast/list/autocomplete'] = array(
    'title' => 'Call Blast Autocomplete List',
    'page callback' => 'callblast_list_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/callblast.inc',
  );
  
  return $items;
}

/**
 * Implementation of hook_block().
 */
function callblast_block($op = 'list', $delta = 0, $edit = array()) {
  if ($op == 'list') {
    $blocks[0]['info'] = t('Call Blast Status');
    return $blocks;
  }
  else if ($op == 'view') {
    switch($delta) {
      case 0: 
        $block['subject'] = t('Call Blast Status');
        $block['content'] = theme('callblast_block'); 
      break;
    }
    return $block; 
  }
}

/**
 * Implementation of hook_theme().
 */
function callblast_theme() {
  return array(
    'callblast_block' => array(
      'arguments' => array(),
    ),
    'callblast_formatter_callblast_list' => array(
      'arguments' => array('element' => NULL),
    ),
    'callblast_formatter_callblast_list_title' => array(
      'arguments' => array('element' => NULL),
    ),
    'callblast_formatter_callblast_list_calls_link' => array(
      'arguments' => array('element' => NULL),
    ),
    'callblast_formatter_callblast_edit_link' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Callback for theme_callblast_list().
 * 
 * @param $element
 *  array, I think this is the $element being passed by CCK here.
 */
function theme_callblast_formatter_callblast_list($element) {
  $output = callblast_list_default($element['#item']['safe']);
  return $output;
}

/**
 * Callback for theme_callblast_list_title().
 * 
 * @param $element
 *  array, I think this is the $element being passed by CCK here.
 */
function theme_callblast_formatter_callblast_list_title($element) {
  $output = callblast_list_title($element['#item']['safe']);
  return $output;
}

/**
 * Callback for theme_callblast_list_calls_link().
 * 
 * @param $element
 *  array, I think this is the $element being passed by CCK here.
 * 
 * todo Replace this workaround with a proper Views handler to create a View Calls link.
 */
function theme_callblast_formatter_callblast_list_calls_link($element) {
  $txt = t('View Calls');
  $path = 'callstatus';
  $options = array('query' => 'callblast_nid='. $element['#node']->nid);
  $output = l($txt, $path, $options);

  return $output;
}

/**
 * Callback for theme_callblast_list_calls_link().
 * 
 * @param $element
 *  array, I think this is the $element being passed by CCK here.
 * 
 * todo Replace this workaround with a proper Views handler to create a callblast-status-aware edit link.
 * todo Use hook_nodeapi and hook_menu_alter to actually prevent user from editing sent callblasts.
 */
function theme_callblast_formatter_callblast_edit_link($element) {
  $node = $element['#node'];
  $blast_sent = $node->node_data_field_callblast_audio_file_field_blast_sent_value;
  // only return an edit link if blast has NOT been sent yet.
  if (!$blast_sent) {
    $txt = t('edit');
    $path = 'node/'. $node->nid .'/edit';
    $output = l($txt, $path);
    return $output;
  } else {
    return '';
  }
}

/**
 * Callback for theme_callblast_block().
 * 
 * Create a block with links to views included
 * in callblast feature module.
 * 
 * @return
 *  $output, html, content of block
 */
function theme_callblast_block() {
  $output = '<div class="callblast">';

  // link to call blast page View
  $txt = t('Call Blasts');
  $path = 'callblast';
  $output .= '<h4>'. l($txt, $path) .'</h4>';

  $txt = t('Calls');
  $path = 'callstatus';
  $output .= '<h4>'. l($txt, $path) .'</h4>';
  
  $output .= '</div>';

  return $output;
}

//----------------------------//
// Views hooks
//----------------------------//

/**
 * Implementation of hook_views_data().
 * 
 * Expose callblast_call table to views, so voipcall
 * nodes can be filtered in Views based on the callblast that 
 * created them.
 */
function callblast_views_data() {
  $data = array();

  // callblast_call table
  $data['callblast_call']['table']['group'] = t('Node');

  // link callblast_call table to node table, join on callblast_nid
  $data['callblast_call']['table']['join']['node'] = array(
    'left_field' => 'nid',
    'field' => 'callblast_nid',
  );

  // link callblast_call table to node table, join on voipcall_nid
  $data['callblast_call']['table']['join']['node'] = array(
    'left_field' => 'nid',
    'field' => 'voipcall_nid',
  );

  // callblast_call.callblast_nid field
  $data['callblast_call']['callblast_nid'] = array( 
    'group' => t('Node'),
    'title' => t('Call Blast Nid'),
    'help' => t('The node ID of the Call Blast node.'),
    'argument' => array(
      // todo? 'handler' => '',
      'name field' => 'title', // the field to display in the summary.
      'numeric' => TRUE,
      'validate type' => 'nid',
    ),
    'field' => array(
      'handler' => 'views_handler_field',
      'click sortable' => TRUE,
    ),
    'filter' => array(
      'handler' => 'views_handler_filter_numeric',
    ),
    'sort' => array(
      'handler' => 'views_handler_sort',
    ),
  );

/*
// TODO figure out why this doesn't work!
  // Call Blast Name field
  $data['callblast_call']['callblast_title'] = array( 
    'group' => t('Node'),
    'help' => t('The human readable title/name of the Call Blast node.'),
    'field' => array(
      'field' => 'callblast_nid', // the real field
      'handler' => 'callblast_handler_field_callblast_call_callblast_title',
      'click sortable' => TRUE,
    ),
  );
// */

  // callblast_call.voipcall_nid field
  $data['callblast_call']['voipcall_nid'] = array(
    'group' => t('Node'),
    'title' => t('Voip Call Nid'),
    'help' => t('The node ID of the Voip Call node.'),
    'argument' => array(
      // todo? 'handler' => '',
      'name field' => 'title', // the field to display in the summary.
      'numeric' => TRUE,
      'validate type' => 'nid',
    ),
    'field' => array(
      'handler' => 'views_handler_field',
      'click sortable' => TRUE,
    ),
    'filter' => array(
      'handler' => 'views_handler_filter_numeric',
    ),
    'sort' => array(
      'handler' => 'views_handler_sort',
    ),
  );

  return $data;
}

/**
 * Implementation of hook_views_handlers().
 */
function callblast_views_handlers() {
  return array(
    'info' => array(
      'path' => drupal_get_path('module', 'callblast') . '/includes',
    ),
    'handlers' => array(
      'callblast_handler_field_callblast_call_callblast_title' => array(
        'parent' => 'views_handler_field',
      ),
    ),
  );
}
 
//------------------//
// End Views hooks 
//------------------//

/**
 * Implementation of hook_form_alter().
 * 
 * TODO Delete this if we don't end up using voipfield.
 */
function callblast_form_alter(&$form, &$form_state, $form_id){
  // callblast node form
  if ($form_id == 'callblast_node_form') {
    // hide 'blast sent' field for users other than user 1
    global $user;
    if ($user->uid != 1) {
      $form['field_blast_sent']['#access'] = FALSE;
    }
    /**
     * If voipfield module is NOT enabled
     * hide the Main Message URL field. 
     */
    if(!function_exists('voipfield_form_alter')) {
      $form['field_callblast_audio_url']['#type'] = 'hidden';
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function callblast_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($op == 'presave' and $node->type == 'callblast') {
    // Only save callblast list name.
    // Don't store human readable name or '(((' ')))'
    $list_name = $node->field_callblast_calllist[0]['value'];
    $list_name = explode('(((', $list_name);
    $list_name = trim(substr($list_name[1], 0, -3));
    $node->field_callblast_calllist[0]['value'] = $list_name;
  }
}

/**
 * On cron, run call blasts.
 * 
 * TODO Add test call before running call blast.
 * TODO Enable user to schedule date/time for test call and blast.
 * TODO Call node_save to update list before running blast. If people have been deleted from a dynamic list, don't call them.
 * 
 * Implementation of hook_cron().
 */
function callblast_cron() {
  // Check for call blasts that have been scheduled but not sent.
  $sql = "SELECT n.nid, n.vid " 
        ."FROM {node} n " 
        ."JOIN {content_type_callblast} cb ON n.nid = cb.nid "
        ."WHERE field_blast_sent_value = 0 ";
  $result = db_query($sql);

  // @todo these should be added to a queue. Lots of big lists could get messy.
  // loop through unblasted blast lists and blast them
  while ($row = db_fetch_object($result)) {
    $callblast_nid = $row->nid;
    $callblast_vid = $row->vid;
  
    // Check when call is scheduled to get sent. 
    // Skip if it's scheduled for later.
    $node = node_load($callblast_nid);
    $start_time =  $node->field_callblast_scheduled_start[0]['value'];
    // TODO Add timezone handling.
    // $timezone = $node->field_callblast_scheduled_start[0]['timezone'];
    $now = time();
    if ($start_time <= $now) {

      // Get selected call list.
      $list = callblast_list($node);
      // Save call list. (Each number on list must
      // be stored as a voipcall node.)
      callblast_save_voipcalls($list, $node);

      // get list of voipcall nids 
      // voip.module gets the phone numbers from the voipcall node
      $sql = 'SELECT voipcall_nid FROM {callblast_call} WHERE callblast_nid = %d'; 
      $result2 = db_query($sql, $callblast_nid);

      // place phone calls to each number on the list, one-by-one
      while ($voipcall_nid = db_result($result2)) { 
        $voipcall_node = node_load($voipcall_nid);    

        // $request_id, Type of call being requested.
        $request_id = 'voip_dial_out';

        // place outgoing call
        voip_send_request($request_id, $voipcall_node);
      }
      // Update node to indicate that blast has been sent.
      db_query("UPDATE {content_type_callblast} "
              ."SET field_blast_sent_value = 1 " 
              ."WHERE nid = %d " 
              ."AND vid = %d ",
               $callblast_nid, $callblast_vid);

      // Clear cache to reflect update.
      cache_clear_all('content:'. $callblast_nid .':'. $callblast_vid, content_cache_tablename()); 

      // Log call blast with watchdog
      $type = 'call blast';
      $message = t("Call blast nid-$callblast_nid sent.");
      $severity = WATCHDOG_NOTICE;
      watchdog($type, $message);
    } // end if ($start_time <= $now)
  } // end while
}

/**
 * TODO delete? cruft.
 * 
 * Batch call back operation: Save voipcall nodes.
 * 
 * @param
 *  $size, number of phone numbers to save per pass 
 * 
 * @param
 *  $list, full call list with phone numbers and any other 
 *  details supplied by the module that created it.
 * 
 *  $node, callblast node, including default values to send to voipcall_save().
 */
function callblast_save_voipcall_nodes($size, $list, $details, $node) {
  // Initialize sandbox the first time through.
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 1;
    $context['sandbox']['i'] = 0;
    $context['sandbox']['max'] = count($list);
  }
  
  // set range of numbers to be processed
  $i = $context['sandbox']['i'];
  $j = 0;
  $max = $context['sandbox']['max']; 

  // save up voipcall nodes from $list
  while ($i < $max && $j < $size) {
    if ($list[$i]['destination']) {
      $details['destination'] = $list[$i]['destination'];
      // save voipcall node
      voipcall_save($details);
      // store callblast_nid / voipcall_nid pairs in  callblast_call table
      $callblast_call->voipcall_nid = db_last_insert_id('node', 'nid');
      $callblast_call->callblast_nid = $node->nid;
      drupal_write_record('callblast_call', $callblast_call);
    } else {
      // no destination number
      // TODO Add validation/error handling here. 
      //   Right now we're just checking for something or nothing. 
      //   But, for example, a 6 digit phone number should trigger an error too.
      drupal_set_message(t('Invalid destination number on call list.'), 'warning');
    }
    $i++;
  }

  // update progress information
  $context['sandbox']['progress']++;
  $context['sandbox']['i'] = $i;
  $context['message'] = t('Scheduling %callnum', array('%callnum' => $list[$i]['destination']));

  // Let the batch engine know how close we are to completion.
  if ($context['sandbox']['progress'] == $context['sandbox']['max']) {
    // Done!
    $context['finished'] = 1;
    $context['results'] = $context['sandbox']['max'];
    // incase 'finished' function wants to use these
  } else {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }  
}

/**
 * TODO Delete. Cruft. (If blast is going to run on cron, not batch process.)
 * 
 * Batch finished. Called when batch operations are complete.
 */
function callblast_save_voipcall_nodes_finished($success, $results, $operations) {
  if ($success) {
    $txt = t('Call blast set up complete.');
    drupal_set_message($txt);
  } else {
    // a fatal error occurred during batch processing
    $error_operation = reset($operations);
    $operation = array_shift($error_operation);
    $arguments = array_shift($error_operation);
    $arguments_as_string = implode(', ', $arguments);
    watchdog('callblast', "Error when calling operation '%s'('%s')", array($operation, $arguments_as_string));
    drupal_set_message(t('An error occurred and has been recorded in the system log.'), 'error');
  }
}
//==========================================//
// DEFINING THE CALLIST WIDGET
// see example:  http://www.lullabot.com/articles/creating-custom-cck-fields
//==========================================//

/**
* Implementation of hook_widget_info().
*
* Here we indicate that the content module will handle
* the default value and multiple values for these widgets.
*
* Callbacks are omitted because default handing is used.
*/
function callblast_widget_info() {
  return array(
    // The machine name of the widget
    'callblast_calllist' => array(
      'label' => t('Call List'),
      'field types' => array('text'),
      // 'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
* Implementation of hook_widget_settings().
* 
* TODO Add hok_widget_settings(). 
* Allow multiple values? (e.g. combine call lists 
* like "summer volunteers" + "interns" CiviCRM groups?)
*/

/**
* Implementation of hook_widget().
*
* @param $form
*   the entire form array, 
*   $form['#node'] holds node information
* @param $form_state
*   the form_state, 
*   $form_state['values'][$field['field_name']]
*   holds the field's form values.
* @param $field
*   the field array
* @param $items
*   array of default values for this field
* @param $delta
*   the order of this item in the array of 
*   subelements (0, 1, 2, etc)
*
* @return
*   the form item for a single element for this field
*/
function callblast_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  $element['value'] = array(
    '#title' => t('Call List'), 
    '#type' => 'textfield',
    '#default_value' => callblast_list_default($items[$delta]['value']),
    '#autocomplete_path' => 'callblast/list/autocomplete',
    '#size' =>  60,
    '#attributes' => array('class' => 'callblast_calllist'),
    '#maxlength' => !empty($field['max_length']) ? $field['max_length'] : NULL,
  );
  
  // Used so that hook_field('validate') knows where to 
  // flag an error in deeply nested forms.
  if (empty($form['#parents'])) {
    $form['#parents'] = array();
  }
  $element['_error_element'] = array(
    '#type' => 'value',
    '#value' => implode('][', array_merge($form['#parents'], array('value'))),
  );
  return $element;
}

/**
 * Callblack for #default_value.
 * Make it human readable.
 * 
 * todo Add error handling to check for two lists with the same id and then throw an error message. 
 */
function callblast_list_default($value) {
  $title = module_invoke_all('callblast_get_title', $value);  
  if ($title[0]) {
    return $title[0] .'  ((('. $value .')))';
  } 
}

/**
 * Callblack for formatting Call List title as
 * human readable, without showing calllist ID. 
 * Make it human readable.
 * 
 * todo Add error handling to check for two lists with the same id and then throw an error message. 
 */
function callblast_list_title($value) {
  $title = module_invoke_all('callblast_get_title', $value);  
  if ($title[0]) {
    return $title[0];
  } 
}

/**
 * hook_field_formatter_info()
 */
function callblast_field_formatter_info() {
  return array(
    'callblast_list' => array(
      'label' => 'Call List',
      'field types' => array('text'),
    ),
    'callblast_list_title' => array(
      'label' => 'Call List Title',
      'field types' => array('text'),
    ),
    'callblast_list_calls_link' => array( // todo temp. replace. see todo note at theme function.
      'label' => 'Call List Calls Link',
      'field types' => array('text'),
    ),
    'callblast_edit_link' => array(      // todo temp. replace. see todo note at theme function.
      'label' => 'Call Blast Edit Link', 
      'field types' => array('text'),
    ),
  );
}

//=============//
// End Widget
//=============//

/**
 * Invoke hook_callblast_get_list to get 
 * the numbers on the list from the module 
 * (or, modules if there are more than one)
 * that provided it.
 * 
 * @param
 *  $node object
 * 
 * @return
 *  string, callblast list selected on callblast node.
 */
function callblast_list($node) {
  $list_name = check_plain($node->field_callblast_calllist[0]['value']);
  $list = module_invoke_all('callblast_get_list', $list_name);

  return $list;
}

/**
 * TODO get rid of this? cruft. no longer in use.
 * 
 * Save a callblast list. This function uses
 * Batch API to process a list of calls and selected
 * callblast options to generated voipcall nodes for
 * each number on the list.
 * 
 * @param
 *  $list, an array of numbers to be called. 
 * 
 * @param
 *  $node, object, a callblast node.
 */
function callblast_save_list($list, $node) {
  // Set up batch 
  $size = 5; // save up 5 nodes at a time
  // generic call details from callblast node
  $details['script'] = $node->field_callblast_script[0]['nid'];
  $details['caller number'] = $node->field_callblast_caller_number[0]['value'];
  $details['caller name'] = $node->field_callblast_caller_name[0]['value'];
  $details['parent node'] = $node->nid;
  $details['scheduled start'] = $node->field_callblast_scheduled_start[0]['value'];
  // batch
  $batch = array(
     'operations' => array(
       array('callblast_save_voipcall_nodes', array($size, $list, $details, $node),),
       ),
     'finished' => 'callblast_save_voipcall_nodes_finished',
     'title' => t('Scheduling calls'),
     'init_message' => t('Creating records for each phone number on call list'),
     'progress_message' => t('Scheduled @current of @total calls.'),
     'error_message' => t('Processing error'),
  );
  $url = "node/$node->nid";
  // Save voipcall nodes
  batch_set($batch);
  batch_process($url);
}

/**
 * @param
 *  $list, an array of numbers to be called. 
 * 
 * @param
 *  $node, object, a callblast node.
 */
function callblast_save_voipcalls($list, $node) {
  global $base_url;

  // generic call details from callblast node
  $details['caller number'] = $node->field_callblast_caller_number[0]['value'];
  $details['caller name'] = $node->field_callblast_caller_name[0]['value'];
  $details['parent node'] = $node->nid; // TODO delete?
  $details['scheduled start'] = $node->field_callblast_scheduled_start[0]['value'];
  $details['script_name'] = 'callblast_message'; 

  // store URL to audio message in script_variable
  $url_tmp = $node->field_callblast_audio_file[0]['filepath'];
  $message_url = ($url_tmp)? $base_url.'/'.drupal_urlencode(check_url($url_tmp)) : NULL;

  // call forwarding number
  $forward_to_number = $node->field_callblast_call_forward[0]['value']; 

  // options
  $url_tmp = $node->field_callblast_audio_options[0]['filepath'];
  $options_url = ($url_tmp)? $base_url.'/'.drupal_urlencode(check_url($url_tmp)) : NULL;

  // message one
  $url_tmp = $node->field_callblast_audio_one[0]['filepath'];
  $one_url = ($url_tmp)? $base_url.'/'.drupal_urlencode(check_url($url_tmp)) : NULL;

  // message two
  $url_tmp = $node->field_callblast_audio_two[0]['filepath'];
  $two_url = ($url_tmp)? $base_url.'/'.drupal_urlencode(check_url($url_tmp)) : NULL;

  // message three
  $url_tmp = $node->field_callblast_audio_three[0]['filepath'];
  $three_url = ($url_tmp)? $base_url.'/'.drupal_urlencode(check_url($url_tmp)) : NULL;

  // message four
  $url_tmp = $node->field_callblast_audio_four[0]['filepath'];
  $four_url = ($url_tmp)? $base_url.'/'.drupal_urlencode(check_url($url_tmp)) : NULL;

  // message five
  $url_tmp = $node->field_callblast_audio_five[0]['filepath'];
  $five_url = ($url_tmp)? $base_url.'/'.drupal_urlencode(check_url($url_tmp)) : NULL;


  // store voipcall variables
  $details['script_variables'] = array(
    'message_url' => $message_url, 
    'forward_to_number' => $forward_to_number,
    'options_url' => $options_url,
    'one_url' => $one_url,
    'two_url' => $two_url,
    'three_url' => $three_url,
    'four_url' => $four_url,
    'five_url' => $five_url,
  );

  // save up voipcall nodes from $list
  $i = 0;
  $count = count($list);
  while ($i < $count) {
    if ($list[$i]['destination']) {
      $details['dest_number'] = $list[$i]['destination'];
      $details['dest_name'] = $list[$i]['name'];
      // save voipcall node
      voipcall_save($details);
      // store callblast_nid / voipcall_nid pairs in  callblast_call table
      $callblast_call->voipcall_nid = db_last_insert_id('node', 'nid');
      $callblast_call->callblast_nid = $node->nid;
      drupal_write_record('callblast_call', $callblast_call);
    } else {
      // no destination number
      // TODO Add validation/error handling here. 
      //   Right now we're just checking for something or nothing. 
      //   But, for example, a 6 digit phone number should trigger an error too.
      drupal_set_message(t('Invalid destination number on call list.'), 'warning');
    }
    $i++;
  }
}
