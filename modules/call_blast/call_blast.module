<?php
/**
 * @file
 *  call_blast.module
 */

// Custom code and logic.
include_once('call_blast.inc');

/**
 * @file call_blast.module
 *   Drupal hooks implemented for VOIP call blasts.
 */ 
/**
 * Implementation of hook_help(). 
 */
function call_blast_help($path, $arg) {
  if ($path == 'admin/help#call_blast') {
    $txt = t('This module creates provides voip '
            .'call blast functionality. ');
    return $txt;
  }
}

/**
 * Implementation of hook_menu().
 */
function call_blast_menu() {
  $items = array();

 // Call back for auto-complete on node/add and node/edit form
  $items['call_blast/list/autocomplete'] = array(
    'title' => 'Call Blast Autocomplete List',
    'page callback' => 'call_blast_list_autocomplete',
    'access arguments' => array('edit extension'),
    'type' => MENU_CALLBACK,
    'file' => 'call_blast.inc',
  );
  
  return $items;
}

/**
 * Implementation of hook_nodeapi().
 */
function call_blast_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  // create call nodes from call blast's call list
  if ($node->type == 'callblast' && $op == 'insert') {

    // Get selected call list
    $list_name = check_plain($node->field_callblast_calllist[0]['value']);
    $list = module_invoke_all('call_blast_get_list', $list_name);

    // Set up batch 
    $size = 5; // save up 5 nodes at a time
    // generic call details from callblast node
    $details['script'] = $node->field_callblast_script[0]['nid'];
    $details['caller number'] = $node->field_callblast_caller_number[0]['value'];
    $details['caller name'] = $node->field_callblast_caller_name[0]['value'];
    $details['parent node'] = $node->nid;
    $details['scheduled start'] = $node->field_callblast_scheduled_start[0]['value'];
    // batch
    $batch = array(
       'operations' => array(
         array('call_blast_save_voipcall_nodes', array($size, $list, $details),),
         ),
       'finished' => 'call_blast_save_voipcall_nodes_finished',
       'title' => t('Scheduling calls'),
       'init_message' => t('Creating records for each phone number on call list'),
       'progress_message' => t('Scheduled @current of @total calls.'),
       'error_message' => t('Processing error'),
    );
    $url = "node/$node->nid";
    // Save voipcall nodes
    batch_set($batch);
    batch_process($url);

    // Set message, success
  }
  // CONTINUE HERE - ADD HANDLING FOR AN UPDATED CALLBLAST NODE
}

// HOOK_NODEAPI -> CREATE CALL NODES ON SAVE
// CALL RELATED CALL NODES ON CRON
// USE CALL BLAST'S MESSAGE
// README.txt, explain hooks implemented in calllist module
// FORM ALTER TO PREVENT MANUAL CREATION OF CALLS (LIKE EXTENSIONS)?
// PROVIDE ADMIN SETTINGS FORM TOE ENABLE MANUAL CREATION OF CALLS? 
// BUILD CIVICRM MODULE


/**
 * On cron, run call blasts.
 * 
 * TODO Add test call before running call blast.
 * TODO Enable user to schedule date/time for test call and blast.
 * 
 * Implementation of hook_cron().
 */
// TODO Update this to pull numbers from designated list.
function call_blast_cron() {
  // check for call blasts that have been scheduled but not sent
  $sql = "SELECT n.nid, n.vid " 
        ."FROM {node} n " 
        ."JOIN {content_type_callblast} cb ON n.nid = cb.nid "
        ."WHERE field_blast_sent_value = 0";
  $result = db_query($sql);

  // loop through unblasted blast lists and blast them
  while ($row = db_fetch_object($result)) {
    $nid = $row->nid;
    $vid = $row->vid;

    // get list of phone numbers for the current call blast list
    $sql = "SELECT field_blast_phone_num_value "
          ."FROM content_field_blast_phone_num "
          ."WHERE nid = %d "
          ."AND vid = %d " ;
    $result2 = db_query($sql, $nid, $vid);

    // Add each number from the blast call list to $options, to be sent to voip.
    // Clear out $options, in case there is an old list stored here.
    $options = array();

    // server sending request
    global $base_url;
    // TODO: once we switch to services.module, the extension '/xmlrpc.php' will have to change
    $variables['VD_XMLRPC_URL'] = 'http://localhost/d6/xmlrpc.php'; // TODO uncomment $base_url . '/xmlrpc.php';
    // user sending request
    global $user;
    $variables['VD_USER_NAME'] = $user->name;
    $options['variables'] = $variables;

    while ($num = db_result($result2)) {
      $options['number'] = $num;
      
      // Set unique call id
      // TODO Use this for keeping track of call status?
      $options['unique_id'] = uniqid();

      // TODO User (creator of blast) needs a way to determine script called here.
      $options['script_name'] = 'hello_world';

      // $request_id, Type of call being requested, 'call list'.
      $request_id = 'voip_dial_out';

      // place outgoing call
      voip_send_request($request_id, $options);
    }
    /**
     * TODO Revisit whether this is still a good way to keep track of "sent".
     * Now that individual calls are sent one-at-a-time, and looking ahead to
     * keeping track of call status number-by-number, we need something 
     * more granular here. Maybe each call becomes a node. And the call blast
     * node gets marked "sent" after all calls go through.
     */
    // Update node to indicate that blast has been sent.
    db_query("UPDATE {content_type_callblast} "
            ."SET field_blast_sent_value = 1 " 
            ."WHERE nid = %d " 
            ."AND vid = %d ",
             $nid, $vid);
    // Clear cache to reflect update.
    cache_clear_all('content:'. $nid .':'. $vid, content_cache_tablename()); 
 
    // Log call blast with watchdog
    $type = 'call blast';
    $message = t("Call blast nid-$nid sent.");
    $severity = WATCHDOG_NOTICE;
    watchdog($type, $message);
  }
}

/**
 * Batch call back operation: Save voipcall nodes.
 * 
 * @param
 *  $size, number of phone numbers to save per pass 
 * 
 * @param
 *  $list, full call list with phone numbers and any other 
 *  details supplied by the module that created it.
 * 
 *  $node, callblast node, including default values to send to voipcall_save().
 */
function call_blast_save_voipcall_nodes($size, $list, $details) {
  // Initialize sandbox the first time through.
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 1;
    $context['sandbox']['i'] = 0;
    $context['sandbox']['max'] = count($list);
  }
  
  // set range of numbers to be processed
  $i = $context['sandbox']['i'];
  $j = 0;
  $max = $context['sandbox']['max']; 

  // save up voipcall nodes from $list
  while ($i < $max && $j < $size) {
    if ($list[$i]['destination']) {
      $details['destination'] = $list[$i]['destination']['value'];
      // save voipcall node
      //$voipcall_node = voipcall_save($details);
      voipcall_save($details);
// CONTINUE HERE
      // call_blast_calls($voipcall_node->nid); // TODO add nid to callblast_calls table
    } else {
      // no destination number
      // drupal_set_message(t(''), 'warning');
      // TODO Add some error handling here for when there's no destination number.
      // TODO $context['results'] doesn't seem to be passing $results to 'finished' function. Telling user how many numbers failed without also saying how many passed seems unhelpful.
    }
    $i++;
  }

  // update progress information
  $context['sandbox']['progress']++;
  $context['sandbox']['i'] = $i;
  $context['message'] = t('Scheduling %callnum', array('%callnum' => $list[$i]['destination']));

  // Let the batch engine know how close we are to completion.
  if ($context['sandbox']['progress'] == $context['sandbox']['max']) {
    // Done!
    $context['finished'] = 1;
    // incase 'finished' function wants to use these
  } else {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }  
}

/**
 * Batch finished. Called when batch operations are complete.
 */
function call_blast_save_voipcall_nodes_finished($success, $results, $operations) {
  if ($success) {
    $num = count($results);
    $txt = t('Call blast set up complete. %num calls scheduled.', array('%num' => $num) );
    drupal_set_message($txt);
  } else {
    // a fatal error occurred during batch processing
    $error_operation = reset($operations);
    $operation = array_shift($error_operation);
    $arguments = array_shift($error_operation);
    $arguments_as_string = implode(', ', $arguments);
    watchdog('call_blast', "Error when calling operation '%s'('%s')", array($operation, $arguments_as_string));
    drupal_set_message(t('An error occurred and has been recorded in the system log.'), 'error');
  }
}
